## 题库聚合接口设计思路（返回题目+答案+选项）

目标：客户端按题型（如单选、多选、判断、填空、计算/综合）请求时，一次返回题目、标准答案及选项/子题，降低前端拼装成本。

### 现状简述

- 题目主表：`teach_question`（含题型 `type`、渠道 `channel_code`、软删 `is_del` 等）。
- 视图：`single_choice_question` 仅过滤 `type` LIKE '%1%'。
- 答案/选项表：`teach_ans_single_choice` + child、`teach_ans_mult_choice` + child、`teach_ans_judgment`、`teach_ans_blank`/`teach_ans_blankchild`、`teach_ans_calcparent` + `teach_ans_calcchild` + `teach_ans_calcchild_item`。
- 外键缺失，应用需按约定将题目 ID 与各答案表主键对应。

### 方案 A：API 层聚合（推荐起步）

思路：保持表结构不变，接口按题型分别查询题目及对应答案/选项，再在服务层组装 JSON。

- 优点：实现简单、改动小；可逐步优化缓存/索引；兼容现有表。
- 缺点：每次需多次查询；类型分支较多。
- 适用：先跑通功能，流量中等；后续可加缓存与批量查询。
- 优化点：
  - 统一约定 `question_id` 与答案表主键对应关系，服务层校验防止脏数据。
  - 按题型批量 IN 查询：题目列表 → 一次性取对应答案/子表。
  - 针对高频题型（单选/多选）增加 `(channel_code, type, is_del)` 索引。
  - 引入缓存：按题型+channel+分页键缓存列表；按题目 ID 缓存聚合结果。

### 方案 B：数据库视图聚合

思路：为每种题型建立带 JOIN 的视图，将题目+答案+选项在 DB 层展开。

- 优点：API 只查视图，SQL 简化；可直接用 ORM 映射。
- 缺点：多层 JOIN/子查询，复杂度高；视图更新成本大；优化和排错困难；MySQL 视图在大数据量下性能不如显式 SQL。
- 适用：题型稳定、结构少变、运维团队习惯用视图。
- 注意：视图里慎用 `LIKE '%1%'` 之类模糊匹配，尽量用精确枚举。

### 方案 C：物化聚合表（定时/触发构建）

思路：构建一张“题目聚合表”或 JSON 列，定时（或触发器/CDC）刷新，把题目+答案+选项预写好。

- 优点：读极快、单表返回；前端零拼装；易做全文/标签索引。
- 缺点：需要写同步逻辑；数据一致性依赖刷新频率；额外存储。
- 适用：读多写少、列表/随机抽题场景；需要稳定低延迟。
- 实现要点：用任务调度（如 cron/队列）重建或增量更新；记录源表版本/更新时间做幂等。

### 方案 D：GraphQL / BFF 聚合

思路：在 BFF/GraphQL 层按前端选取字段，后端内部走多次查询或调用服务层聚合。

- 优点：前端灵活取字段；易扩展多终端。
- 缺点：引入新栈；需要良好缓存和 N+1 防护。
- 适用：多端、多变字段需求。

### 方案 E：存储过程/函数返回聚合结果

思路：为各题型写存储过程，输入题目 ID 列表，返回结果集或 JSON。

- 优点：减少往返；逻辑靠近数据。
- 缺点：可维护性差、版本管理麻烦；调试不便；跨环境迁移要同步 SQL。
- 适用：团队熟悉存储过程且题型稳定。

### 方案 F：按题型分服务/分表 CQRS

思路：读写分离，写端保持现状，读端为各题型准备专门的“投影”表或文档存储（如写入 Mongo/ES）。

- 优点：读性能最优，支持全文、组合查询；可水平扩展。
- 缺点：架构复杂度高，需要双写或 CDC，运维成本上升。
- 适用：高并发查询、复杂筛选/搜索场景。

### 选型建议

- 短期：采用方案 A，先实现服务层聚合 + 缓存；为高频题型补充必要索引。
- 中期：若读多写少且数据量上升，可引入方案 C 的物化聚合表；或为单选/多选建立轻量视图作为过渡。
- 长期/高并发：考虑方案 F，引入投影/搜索引擎；或在 BFF 层用 GraphQL 聚合并结合缓存。

### API 形态示例（不含具体实现）

- 路由示例：`GET /api/questions?type=single_choice&channel=...&page=1&page_size=20`
- 响应示例字段：
  - `id, type, subject, content, analysis, options[], answer`（多选可返回 `answers` 数组；填空/计算题返回 `sub_items` 或 `blanks`）。
  - 元数据：`channel_code, sort, created_at, is_del`。
- 分页与过滤：按 `type`、`channel_code`、`subject_id/chapter_id`、`attr` 等。

### 数据与索引建议

- 为 `teach_question` 添加组合索引：`(channel_code, type, is_del, sort)`；如常用按科目筛选，增加 `(channel_code, subject_id, is_del)`.
- 为子表的外键列（如 `singlechoice_id`, `multchoice_id`, `calcparent_id`, `calcchild_id`）添加索引以支撑批量 IN 查询。
- 补充外键或在应用层校验“题目存在且未软删”，防止孤儿记录。

### 缓存策略（配合方案 A/C/F）

- 细粒度：按题目 ID 缓存聚合结果；写入/变更时删缓存。
- 粗粒度：按查询条件（type+channel+page）缓存列表 ID；再批量回源。
- 设置短 TTL + 主动失效，避免陈旧数据。

### 风险与注意

- 题型枚举需统一（避免 `LIKE '%1%'` 模糊匹配带来混淆）。
- 软删除字段需在查询层统一过滤。
- 若继续用视图，注意 MySQL 视图优化限制；大表 JOIN 需有覆盖索引。
- 明文密码连接 MySQL 不安全，可改用配置文件或环境变量。
